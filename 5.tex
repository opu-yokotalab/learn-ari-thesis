\section{自動採点}
\subsection{採点上の問題点}
\label{sec:sai_mon}
穴埋め問題の穴を大きくした場合，プログラムによっては複数の解答が考えられるものがある．
これは，C言語では違う記法で同じ動作を書くことができるために，学習者のプログラミングの書き方や知識の違いから起こる．
異なる記法で同じ動作を行う解答に対してADELのテスト機構\cite{c:test}では，複数の解答を問題作成時に問題作成者が複数の模範解答を登録することで対応してきた．
さらに，自動生成システム\cite{c:ikeda}においても複数パターンの解答がある場合には問題作成者が手動で登録するという手法をとっていた．
しかし，この手法では解答のパターンが多く考えうる場合，すべてのパターンに対して解答を登録してもらうことは問題作成者に多くの負担がかかっていた．
また，問題作成者任せで複数パターンの解答に対応していると問題作成者が登録し忘れた場合，回答自体は正解なのに不正解になるといったことが起こりうる．
これでは，問題ごとに採点基準が異なってしまう危険性が考えられる．

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=10cm,height=5cm]{image/wrong_write.eps}
\caption{違う記法で同じ動作のプログラム例}
\label{fig:wrong_write}
\end{center}
\end{figure}

\subsection{採点手法}
そこで，\ref{sec:sai_mon}節で述べた問題点について対応した採点手法について述べる．
採点機構では，「対応テーブルによる変数の比較」，「正規フォーマットへの変換」，「構文木同士の比較」といった3段階の過程で採点を行う．

\subsubsection{対応テーブルによる変数の比較}
変数の採点において，ADELのテスト機構などの採点ではソースコード中の同一変数をすべて穴にした場合，
模範解答の変数名と同じでないと正解にならなかった．
しかし，変数名が何であれ変数の対応関係が合っていれば正解にしてもプログラムとしては問題がない．
よって，変数名が模範解答と異なっていても対応関係が合っていれば正解にする必要がある．

そこで，変数の対応関係に基づき正誤判定を行う．
まず，構文解析を行うときに変数にidをつけ，変数の対応テーブルを作成しておく．
その対応テーブルを用いて変数の位置の対応関係が共通か判断を行う．
構文木の変数のノードIDを比較し，対応関係を判定する．

%処理部分に変数が出てきた場合，そのノードのidを対応テーブルに書き込む．

\subsubsection{正規フォーマットへの統一}
\ref{sec:sai_mon}節で述べたように,異なる記法で同一の処理を表すものがある．異なる記法で同一の処理を表す記述に対して
問題作成者にすべてのパターンの模範解答を用意してもらうのは手間がかかる．
そこで，違う記法で同じ動作を行うコードに対して，ある統一された記法に変換を行う．
本研究では，その統一された記法を正規フォーマットと呼ぶ．
違う記法で同じ動作を行うものは様々な種類がある．たとえば，$c(a+b)$と$ac+bc$などの「分配法則」は
異なる記法で同一の動作を表す．また，$a+b$と$b+a$のような「可換律」も同様である．
そこで，今回「繰り返し構文」，「分配法則」，「結合法則」，「可換律」について正規フォーマットに変換
出来るように対応した．この正規フォーマットへの統一は構文解析をした構文木に対して行う．

「繰り返し構文」はfor文とwhile文について対応する．これらはそれぞれ同じ動作を記述可能なので
書き換えることが可能である．この構文についてはfor文に統一する．

「分配法則」は先ほど述べたようなカッコをつけた形でも，外した形でも正解となるようにする．
分配法則ではカッコを外した状態「$c(a+b)$の場合だと$ac+bc$」に統一する．

「結合法則」では$a(b*c)$と$(a*b)c$などの記述の違いに対応する．
結合法則でもカッコを外した形に統一する．先程の例だとa*b*cという形に変更する．

最後に，「可換律」では位置を交換できるものを変数を辞書順に並べ替える．

\subsubsection{構文木の比較}
構文木の比較処理では,正解判定を行う学習者の回答の構文木と
問題作成者が作ったソースから生成した解答の構文木の２つを用いて構文木の比較を行う．
これら2つの構文木は正規フォーマットに統一された後に比較される．

比較方法は幅優先にノードの比較を行い，ルートノードから順に対応するノードを決定していく．
対応するノードの決定のために行う比較では，ノード名で文字列比較を行い，一致すれば対応するノードとする．
また，一致するノードが複数ある場合は一番初めに一致したノードと対応させるようにする．
一度一致したノードは次のノード比較には含まないように除外し，
1つのノードが複数のノードと対応するという事態を防ぐ．

このノードの比較を回答の構文木のすべてのノードに対して行い，構文木ごとのノードの対応関係を作成する．
その対応関係において，対応しないノードがあればそこを間違いとして学習者に提示する．

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=13cm,height=9cm]{image/hikaku.eps}
\caption{構文木比較の例}
\label{fig:hikaku}
\end{center}
\end{figure}

\subsubsection{採点の流れ}
学習者が穴を埋め採点ボタンを押したときに採点が始まる．まず，穴を埋めた回答と問題文のソースコードをもとに
問題文の穴の部分に回答を埋め，回答のソースコードを作成する．作成したソースを構文解析し構文木の作成を行う．
この時，構文解析に通らなかった場合プログラムの内容に間違いが含まれているので，回答は間違いだと判断する．
続いて，問題データベースから解答の構文木を取得し，2つの構文木を正規フォーマットに変換する．
そして,問題作成時に作成した構文木と比較を行い，構造の違いのチェックを行う．

また，変数の位置をすべて穴をあけた場合は対応テーブルをもとに，
学習者が入力した文字が問題作成者の意図した文字列でなくても，
必要な場所にすべて同じ文字列が入っているかどうか判定する．

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=10cm,height=7cm]{image/not_found.eps}
\caption{採点の流れ}
\label{fig:answer_flow}
\end{center}
\end{figure}

\newpage
%-------------------------------------------------------------------
%まず，変数を
%正規化機構で正規フォーマットに変換する．そして構文木の比較機構
%に正規フォーマットに統一された構文木を
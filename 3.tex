\section{問題の自動生成}
\label{sec:jidosei}
この章では\ref{sec:approach}節で述べたアプローチの穴埋め問題の自動生成について述べる．
問題の自動生成は穴埋め問題自動生成システム\cite{c:ikeda}をもとに作成されている．

\subsection{自動生成機構}

\subsubsection{生成する問題}
プログラミングの演習問題ではプログラムを一から記述させる記述問題，プログラム中のあるまとまりを空欄にし，
空欄により隠された部分を推定し記述させる穴埋め問題，穴埋め問題の答えを複数の候補の中から選択する選択問題など
複数のバリエーションがある．

しかし，記述問題ではプログラムを一から作らせるため，学習初期の学習者にはハードルが高く学習意欲をそぐ可能性がある．
さらに，プログラムを問題文のみから設計して作らせるため，プログラム設計が上手くできず問題作成者の意図した学習効果が得られない可能性がある．
また，選択問題では複数の選択肢の中から答えを選ぶので適当に答えても正解になる可能性があり，
ここでも意図した学習効果が得られないことがあると考えられる．

そのため，今回はプログラムの一部分を穴にしてその部分のコードを書かせる穴埋め問題が有効であると考える．
穴埋め問題ではプログラムのソースを読み穴の部分を考えるため，学習者の実力を判定するだけでなく，
ソースコードを読む力が養われたり，プログラムの書き方の例を示すことが出来る．
さらに，ある程度のプログラムを学習者に示すため，的外れなプログラムを書くことはなく，
選択問題のように選択肢がないために勘で答えるといったことが難しなる．

よって，本論文では穴埋め問題を用いて学習を行うこととする．生成する問題例を図\ref{fig:mon_rei}に示す．
\begin{figure}[h]
\begin{center}
\includegraphics[width=8cm,height=8cm]{image/mon_rei.eps}
\caption{生成する問題例}
\label{fig:mon_rei}
\end{center}
\end{figure}

\newpage

\subsubsection{問題生成の流れ}
\begin{figure}[h]
\begin{center}
\includegraphics[width=9cm,height=7cm]{image/make_flow.eps}
\caption{問題生成の流れ}
\label{fig:mon_flow}
\end{center}
\end{figure}

問題作成では図\ref{fig:mon_flow}で示す流れで自動的に穴埋め問題の生成を行う．
まず，問題作成者は問題にするためのソースコードを用意する．
用意したソースコードをシステムに読み込ませると構文解析が行われ構文木に変換される．
続いて問題作成者は後述する問題作成意図を選択し，どんな問題を出題したいのかを決定する．
システムでは問題作成意図を対応した問題作成ルールに変換し，
構文解析により作成した構文木に問題作成ルールを適応する．
そうするとソースコードをもとにした自動的に穴埋め問題が作成される．
その後，作成された問題は構文解析で生成した構文木と一緒に問題データベースに登録される．


\subsection{構文解析}
\label{sec:koubun}
C言語のソースコードをシステムの入力とする．入力したソースコードは，構文解析を行い構文木の形に変換される．
また，同時に変数の対応テーブルが作成され,すべての変数には変数IDがふられる．
さらに，その対応テーブルに準じた形で変数を表す葉には属性として変数IDが付加される．

構文解析によって得られる構文木の主な仕様を述べる．
\begin{description}
\item[{\bf 根}]
構文木の根はプログラム1つにつき1つのみ存在し，値はヌルを持つ．
直下の子には唯一SOURCE節のみ持ち，他の要素が根の子になることはない．
\item[{\bf 節}]
C言語プログラムの構造を分かりやすく表すために付加される．たとえば，ソースコード全体を表す
SOURCE節，宣言部分を表すDECLARATION節，main関数などの関数を表すFUNC節などがあり，その節の子にそれらが示す内容を表している．
また，プログラムの一部分も節になり，代入演算子や論理演算子，構文なども節に置換される．
この節は主に意味のある単位で部分木を抽出するために使用される．問題生成では問題作成ルールで指定された
部分木を穴に変換しているので，その部分木の指定時に節をもとに探索される．

\item[{\bf 葉}]
構文木の葉要素となるのは，定数，変数名，型名，関数名がなる．
\end{description}

節はプログラムの構造を示すラベル節とソースコードの一部分を置換する置換節に分かれる．
主なラベル節を表\ref{tab:branch1}に，主な置換節を表\ref{tab:branch2}に示す．

\begin{table}[h]
%\begin{center}
\begin{tabular}{cc}
\begin{minipage}{0.5\hsize}
\begin{center}
\caption{構文解析木の節（ラベル）}
\begin{tabular}{|c|c|}
\hline
節の名前 & 節が表す意味 \\ \hline \hline
DECLARATION & 宣言 \\ \hline
TYPEDEF & 型宣言 \\ \hline
TYPE & 型名 \\ \hline
FUNC & 関数 \\ \hline
GLOBAL & グローバル領域 \\ \hline
%FNAME & 関数名 \\ \hline
BLOCK & \{\}で囲まれた部分 \\ \hline
STATEMENT & 文 \\ \hline
%VARIABLE & 変数 \\ \hline
EXPRESSION & 式 \\ \hline
FORMAT & フォーマット指定子 \\ \hline
ARGUMENTS & 引数群 \\ \hline
ASSIGNMENT & 代入 \\ \hline
LASSIGNMENT & 代入の左辺 \\ \hline
RASSIGNMENT & 代入の右辺 \\ \hline
%LVALUE & 左辺値 \\ \hline
RVALUE & 右辺値 \\ \hline
ARRAY & 配列 \\ \hline
STRUCT & 構造体 \\ \hline
MEMBER & 構造体のメンバ \\ \hline
NONE & 式の省略 \\ \hline
\end{tabular}
\label{tab:branch1}
\end{center}
\end{minipage}

\begin{minipage}{0.7\hsize}
\begin{center}
\caption{構文解析木の節（置換）}
\begin{tabular}{|c|c|}
\hline
節の名前 & 節が表す意味 \\ \hline \hline
FOR,DO,IF... & 各構文 \\ \hline
ASSIGNMENT & 代入 \\ \hline
PLUS & 加算 \\ \hline
MINUS & 減算 \\ \hline
UNARYPLUS & 前置インクリメント \\ \hline
UNARYMINUS & 前置デクリメント \\ \hline
POSTFIXPLUS & 後置インクリメント \\ \hline
POSTFIXMINUS & 後置デクリメント \\ \hline
AMP & アドレス演算 \\ \hline
DOT & ドット演算 \\ \hline
ARROW & アロー演算子 \\ \hline
EQUAL & 等価演算子 \\ \hline
FEWER & 比較演算子 \\ \hline
AND & 論理和 \\ \hline
NOT & 否定 \\ \hline
\end{tabular}
\label{tab:branch2}
\end{center}
\end{minipage}
\end{tabular}
%\end{center}
\end{table}

\newpage

\begin{figure}[t]
\begin{center}
\includegraphics[width=10cm,height=10cm]{image/kaiseki_rei.eps}
\caption{プログラムの解析例}
\label{fig:kaiseki_rei}
\end{center}
\end{figure}

構文解析を行った例を図\ref{fig:kaiseki_rei}に示す．
この図では左のソースコードを構文解析した結果の構文木が右に示すものになる．

\newpage
%%%%%%%%%%%%%%%%%%%%改ページ

\subsection{問題作成意図}
\label{sec:ito}
問題作成意図とは，問題作成者が「こんな目的で問題を作りたい」と考えている内容であり，
ある学習目標に対し，「正解できれば，これが理解できている」という指針になるものである．
この問題作成意図は，満たしたい学習目標ごとに様々なものがある．

例えば，構文について学習させたい時，問題作成意図としては「出力文が分かっているのか確認したい」，
「for文の引数が分かっているのか確認したい」，「処理の流れが分かっているのか確認したい」
等さまざまな問題作成意図が挙げられる．
それらの意図を選択することにより，意図に対応した問題が作成されるようにする．

今回はプログラミングの学習初期の内容についての考えられる学習意図について考えた．
表\ref{tab:ito}は問題作成意図の例である．

\begin{center}
\begin{table}[h]
\caption{問題作成意図の例}
\begin{tabular}{|c|}
\hline
入力関数の引数が分かっているか \\ \hline
制御構文の引数が分かっているか \\ \hline
出力関数の引数が分かっているか \\ \hline
関数を使うのに必要なヘッダが分かっているか \\ \hline
必要となる引数が分かっているのか \\ \hline
所定の演算子が使えるか \\ \hline
処理の流れを理解しているか \\ \hline
配列の定義のしかたが分かっているのか \\ \hline
フォーマット指定子が分かっているか \\ \hline
演算子の使い方が分かっているか \\ \hline
どこでどの変数を持ちいらなければならないか分かっているか \\ \hline
返り値が分かっているか \\ \hline
必要な関数が分かっているか \\ \hline
処理内容が分かっているか \\ \hline
自分でプログラムを作れるか \\ \hline
出力結果のイメージができるか \\ \hline
出力関数の動きが分かっているか \\ \hline
\end{tabular}
\label{tab:ito}
%%表2
\end{table}
\end{center}


表\ref{tab:ito}で表された意図は抽象的で，具体的にどんな問題を作成するのか決まっておらず，問題作成意図から問題を作成するのは難しい。
そこで、この問題作成意図は、単純化・具体化するために、以降に説明する問題作成ルールを組み合わせることによって表現する。
問題作成意図と問題作成ルールの対応付けはシステム側で用意する．
しかし，それでは作りたい問題ができないと問題作成者が思った場合，問題作成者が問題作成ルールを組み合わせて
新規に問題作成意図を作成することも可能とする．


\subsection{問題作成ルール}
\label{sec:rule}
問題作成ルールは構文木のどの部分を穴にするかを指定する記述である．
このルールに従って問題生成部で構文木の部分木が穴に置換され問題が作成される．
問題作成ルールは以下のような記述を持つものになる．
この記述を複数個組み合わせることにより問題作成意図を表現する。
\begin{center}
{\bf createblank(枝名,指定(,指定内容))}
\end{center}
枝名には表\ref{tab:branch1}，表\ref{tab:branch2}で示した構文木の節が来る．
この指定した節以下を穴埋めの穴と置き換える．

指定には"all"または"select"が入り，"all"の場合は枝名で指定した枝の下はすべて穴になる．
また，"select"を入れた場合は，後の指定内容で指定したとおりの穴のあき方になる．

指定内容では，枝名で指定した部分の中でも一部分にだけ穴を開けたい場合に指定するのに用いる．
しかし，この部分指定では構文解析で分割された単位以下の指定はできない．
ここで用いれるものは，rootonly(枝名となっている部分のみを書き換える)，
nameonly(子要素の変数名のみ書き換える)，numberonly(変数の値のみ書き換える)，
conditiononly(条件式のみ書き換える)などがある。


\begin{table}[h]
\begin{center}
\caption{指定内容一覧}
\begin{tabular}{|c|c|}
\hline
指定内容 & 実行内容 \\ \hline \hline
rootonly & 枝名となっている部分のみを書き換える \\ \hline
nameonly & 子要素の変数名のみ書き換える \\ \hline
numberonly & 変数の値のみ書き換える \\ \hline
conditiononly & 条件文のみ書き換える \\ \hline
etc... & etc...\\ \hline
\end{tabular}
\label{tab:sitei}
\end{center}
\end{table}


\subsection{問題生成}
\label{sec:seisei}

問題は\ref{sec:koubun}節で述べた構文解析の結果の構文木と\ref{sec:ito}節で述べた問題作成意図を用いて問題を生成する．
最初に，問題作成意図からそれに対応付けされた問題作成ルールを確定させ，
その選ばれた問題作成ルールから構文木のどの部分を穴に置き換えるかを探し出す．
穴に置き換える部分を探すのには，まず問題作成ルールの枝名を読み，構文木から枝名と一致する部分木を見つける．
次に指定のところで記述された内容に従ってその部分木を穴の記述に置き換える．
それをすべての問題作成ルールに対して順に適用させていき，穴の埋め込まれた構文木を作成する．

そして，出題にはADELのテスト機構\cite{c:test}での問題の流用を想定して，構文木をテスト機構でも扱えるテスト記述に成型する．
このテスト記述の構造は後に示すXMLの形式になっている．生成する問題には問題ごとに問題idがふられ，グループ分けされたうえで,
後の\ref{sec:pool}節で述べる問題データベースに格納される．

テスト記述の内容について以下に示す．

\begin{center}
\begin{description}
\item[{\bf program\_set}] 
問題のグループを持つ要素で，問題グループを識別するid属性を持つ．子要素には複数のitem要素を含む．
\item[{\bf item}]
問題候補のルート要素であり，固有の識別子であるid属性と問題の形式を表すtype属性をもつ．item1つが問題１問に相当する．子要素にquestion要素，response要素，hints要素，explanation要素，evaluate要素をもつ．
\item[{\bf question要素}]
問題の内容を記述する要素で，穴が開けられたソースコードはここに記述される．
\item[{\bf response要素}]
提示の際に解答の候補として記述され，穴埋め問題の解答欄の数に比例する．
\item[{\bf hints要素}]
問題に対するヒントが記述されている．
\item[{\bf evaluate要素}]
採点に関する事柄を記述する要素．子要素にfunction,correct,score,weight,pointを持つ．
\item[{\bf correct要素}]
正解となる文字列を記述する．この要素と解答を比較し正解判定を行う．
\item[{\bf point要素}]
この問題を正解すると加算される点数を記述する．
\item[{\bf explanation要素}]
採点後に表示される文字列を記述する．
\end{description}
\end{center}


\subsection{問題の蓄積}
\label{sec:pool}
問題の自動生成により作られた問題を出題機構で用いるためデータベースへ蓄積を行う．
問題を蓄積するデータベースを問題データベースと名付けた．

問題の自動生成機構で作成された問題は\ref{sec:seisei}節で述べられたXMLの形でデータベースに格納される．
データベースに蓄積されるとき，問題には問題の識別子の問題IDとプログラムセットが付加される．
問題IDは問題を呼び出す時に用いられる識別子となり，複数の問題で重複することはない．
また，プログラムセットは問題のグループを示す．
問題のグループ分けはプログラムの内容ごとに分けられており，出題時にグループを考慮した出題で用いる．

さらに，\ref{sec:koubun}節で作成された構文木もデータベースに登録され，採点時に用いられる．
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%プログラムの一部分を穴にするときに部分木単位で穴に変換するために用いる
%問題作成者の意図を反映させて問題を作るために問題作成者が指定する．
%後述する問題作成ルールを組み合わせることによって表現している
%まず，構文解析した結果の変数となる葉にidを付け，変数名から変数名とidの対応表を作る．
%この対応表では，同じ変数は同一のidで定義される．

